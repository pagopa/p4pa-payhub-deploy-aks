# Template for executing Postman tests on specific applications
parameters:
  # List of applications to test
  - name: appsList
    displayName: 'Applications List'
    type: object
    default: []
    # The list of applications to run Postman tests against
    # Example: ['app1', 'app2', 'app3']

  # Target environment
  - name: env
    displayName: 'Target Environment'
    type: string
    # The environment to run tests in (dev, uat, prod)

  # Azure DevOps agent pool name
  - name: agentPoolName
    displayName: 'Agent Pool Name'
    type: string
    # The name of the Azure DevOps agent pool to use

  # Job identifier suffix
  - name: appCategory
    displayName: 'App Category Identifier'
    type: string
    # Application type identifier

  # Dependency job
  - name: dependsOn
    displayName: 'Dependent Job'
    type: string
    default: ''
    # Name of the job this execution depends on

  # Postman tests branch
  - name: postmanBranch
    displayName: 'Postman Tests Branch'
    type: string
    default: 'develop'
    # Branch containing the Postman tests

  # Max retry attempts for failed tests
  - name: maxRetryAttempts
    displayName: 'Max Retry Attempts'
    type: number
    default: 2
    # Maximum number of retry attempts for failed tests

  # Timeout for each collection
  - name: collectionTimeout
    displayName: 'Collection Timeout (seconds)'
    type: number
    default: 300
    # Timeout in seconds for collection execution

  # Key Vault parameters
  - name: keyVaultName
    displayName: 'Key Vault Name'
    type: string
    # Name of the Azure Key Vault containing the environment file

  - name: secretName
    displayName: 'Secret Name'
    type: string
    # Name of the secret containing the Postman environment file

  - name: azureServiceConnection
    displayName: 'Azure Subscription'
    type: string
    # The name of the Azure Service Connection to use for Key Vault access

jobs:
- job: postman_${{ parameters.appCategory }}
  displayName: 'üõÉ ${{ parameters.appCategory }}'
  timeoutInMinutes: 60
  dependsOn: ${{ parameters.dependsOn }}
  condition: succeeded()
  strategy:
    matrix:
      ${{ each item in parameters.appsList }}:
        ${{ replace(item, '-', '_') }}:
          appName: ${{ item }}
  pool:
    name: ${{ parameters.agentPoolName }}
  variables:
    testOutcome: 'Succeeded'
  steps:
    - checkout: self
      name: checkoutSourceCode
      displayName: 'Checkout Source Code'

    - task: Bash@3
      name: validatePostmanConfig
      displayName: 'Validate Postman Configuration'
      inputs:
        targetType: 'inline'
        script: |
          echo "üîç Validating Postman configuration..."
          # Extract configuration from values.yaml
          rootPostman=$(yq '.postman-test' $(Build.Repository.LocalPath)/helm/${{parameters.env}}/${{parameters.appCategory}}/$(appName)/values.yaml)
          runPostmanTests=$(yq '.postman-test.run' $(Build.Repository.LocalPath)/helm/${{parameters.env}}/${{parameters.appCategory}}/$(appName)/values.yaml)

          echo "Configuration found:"
          echo "- Root config: $rootPostman"
          echo "- Run tests: $runPostmanTests"

          # Validate if configuration exists and is not null
          function is_valid_config() {
              [ ! -z "$1" ] && [ "$1" != "null" ]
          }

          # Check if tests should be executed based on configuration
          if ! is_valid_config "$rootPostman" || ! is_valid_config "$runPostmanTests" || [ "$runPostmanTests" != "true" ]; then
              echo "##vso[task.logissue type=warning]‚ö†Ô∏è Skipping Postman tests - Configuration not valid or tests disabled"
              echo "##vso[task.setvariable variable=runPostmanTest;isOutput=true]false"
              exit 0
          fi

          echo "‚úÖ Postman configuration validated successfully"
          echo "##vso[task.setvariable variable=runPostmanTest;isOutput=true]true"

    - task: Bash@3
      name: setupTestEnvironment
      displayName: 'Setup Test Environment'
      condition: and(succeeded(), eq(variables['validatePostmanConfig.runPostmanTest'], 'true'))
      inputs:
        targetType: 'inline'
        script: |
          echo "üîß Configuring test environment..."

          # Extract test configuration from values.yaml
          repoName=$(yq '.postman-test.repoName' $(Build.Repository.LocalPath)/helm/${{parameters.env}}/${{parameters.appCategory}}/$(appName)/values.yaml)
          dir=$(yq '.postman-test.dir' $(Build.Repository.LocalPath)/helm/${{parameters.env}}/${{parameters.appCategory}}/$(appName)/values.yaml)
          collectionName=$(yq '.postman-test.collectionName' $(Build.Repository.LocalPath)/helm/${{parameters.env}}/${{parameters.appCategory}}/$(appName)/values.yaml)

          echo "üìã Test Configuration:"
          echo "- Repository: $repoName"
          echo "- Directory: $dir"
          echo "- Collection: $collectionName"
          echo "- Branch: ${{ parameters.postmanBranch }}"

          # Validate individual configuration values
          function validate_variable() {
              [ ! -z "$1" ] && [ "$1" != "null" ]
          }

          # Define required variables
          declare -a required_vars=(
            "repoName:$repoName"
            "dir:$dir"
            "collectionName:$collectionName"
          )

          # Check for missing required variables
          missing_vars=()
          for var in "${required_vars[@]}"; do
            name="${var%%:*}"
            value="${var#*:}"

            if validate_variable "$value"; then
              echo "##vso[task.setvariable variable=$name]$value"
            else
              missing_vars+=("$name")
            fi
          done

          # Handle missing variables
          if [ ${#missing_vars[@]} -gt 0 ]; then
            echo "‚ùå Missing required variables: ${missing_vars[*]}"
            echo "##vso[task.logissue type=warning]Configuration incomplete"
            echo "##vso[task.setvariable variable=runPostmanTest;isOutput=true]false"
            exit 0
          fi

          echo "‚úÖ Test environment configured successfully"
          echo "##vso[task.setvariable variable=runPostmanTest;isOutput=true]true"

    - task: NodeTool@0
      displayName: 'Install Node.js'
      inputs:
        versionSpec: '18.x'

    - task: Npm@1.238.1
      displayName: 'Install Newman CLI'
      inputs:
        command: custom
        customCommand: install -g newman

    - task: Bash@3
      displayName: 'Install jq'
      inputs:
        targetType: 'inline'
        script: |
          sudo apt-get update
          sudo apt-get install -y jq

    - task: AzureKeyVault@2
      displayName: 'Fetch Key Vault Secrets'
      inputs:
        ConnectedServiceName: '${{ parameters.azureServiceConnection }}'
        KeyVaultName: '${{ parameters.keyVaultName }}'
        SecretsFilter: '${{ parameters.secretName }}'
        RunAsPreJob: false

    - task: Bash@3
      name: setupPostmanEnvironment
      displayName: 'Setup Postman Environment File'
      inputs:
        targetType: 'inline'
        script: |
          echo "üîê Setting up Postman environment from Key Vault..."
          
          # Create directory for environment file
          mkdir -p $(Pipeline.Workspace)/postman
          
          # Save the secret content directly to a file
          echo "$($(parameters.secretName))" > $(Pipeline.Workspace)/postman/environment.json
          
          # Validate JSON format
          if ! jq empty $(Pipeline.Workspace)/postman/environment.json 2>/dev/null; then
            echo "##vso[task.logissue type=error]Invalid JSON format in environment file"
            exit 1
          fi
          
          # Set variable for the file path
          echo "##vso[task.setvariable variable=postmanEnvFile]$(Pipeline.Workspace)/postman/environment.json"
          
          echo "‚úÖ Postman environment file created successfully"

    - task: Bash@3
      name: executePostmanTests
      displayName: 'Execute Postman Tests'
      condition: and(succeeded(), eq(variables['setupTestEnvironment.runPostmanTest'], 'true'))
      continueOnError: true
      inputs:
        targetType: inline
        script: |
          # Error handling function
          function handle_error() {
            local error_message=$1
            echo "‚ùå $error_message"
            echo "##vso[task.logissue type=error]$error_message"
            return 1
          }

          # Function to execute tests with retry mechanism
          function execute_tests_with_retry() {
            local max_attempts=${{ parameters.maxRetryAttempts }}
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              echo "üîÑ Attempt $attempt of $max_attempts..."

              # Run Newman with specified configuration
              if newman run $(collectionName) \
                 -e $(postmanEnvFile) \
                 --reporters cli,junit \
                 --reporter-junit-export result/test-result.xml \
                 --timeout ${{ parameters.collectionTimeout }}000; then
                return 0
              fi

              # Handle retry logic
              ((attempt++))
              [ $attempt -le $max_attempts ] && {
                echo "‚è≥ Waiting before retry...";
                sleep 10;
              }
            done

            return 1
          }

          set -e
          echo "üöÄ Starting test execution for $(appName)..."

          # Log test configuration
          echo "üìù Test Configuration:"
          echo "- Repository: $(repoName)"
          echo "- Directory: $(dir)"
          echo "- Collection: $(collectionName)"
          echo "- Branch: ${{ parameters.postmanBranch }}"

          # Clone test repository
          echo "üì¶ Cloning test repository..."
          if ! git clone -b ${{ parameters.postmanBranch }} https://github.com/pagopa/$(repoName).git; then
            handle_error "Failed to clone repository"
            exit 1
          fi

          # Navigate to test directory
          cd $(repoName)/$(dir) || {
            handle_error "Failed to navigate to test directory"
            exit 1
          }

          # Execute tests with retry mechanism
          if ! execute_tests_with_retry; then
            handle_error "Tests failed after ${{ parameters.maxRetryAttempts }} attempts"
            exit 1
          fi

          echo "‚úÖ Tests completed successfully"

    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-*.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)/$(repoName)/$(dir)/result/'
        testRunTitle: 'Postman Tests - ${{ parameters.appCategory }} - $(appName)'

    - bash: |
        # Check test outcome and finalize execution
        if [ "$(testOutcome)" == "SucceededWithIssues" ]; then
          echo "‚ö†Ô∏è Tests completed with issues"
          echo "##vso[task.logissue type=warning]Tests completed with issues, marking as successful"
        else
          echo "‚úÖ Tests completed successfully"
        fi
        echo "##vso[task.complete result=Succeeded;]"
      name: finalizeTests
      displayName: 'Finalize Test Execution'
      condition: always()